(in-package #:gfxmath.test)

(plan nil)

(progn
  (oa= (m:quat 1 2 3 4) #(1 2 3 4) "quaternion: quat")
  (o= (m:quat/id) (q 1 0 0 0) "quaternion: quat/id")
  (o= (m:quat/from-axis-angle (v 0 1 0) (/ pi 3))
      (q 0.86602545 0 0.5 0)
      "quaternion: quat/from-axis-angle")
  (o= (m:quat/from-mat
       (m (v 1 0 0) (v 0 0.5 0.86602545) (v 0 -0.86602545 0.5)))
      (m:rotate (qid) (v (/ pi 3) 0 0))
      "quaternion: quat/from-mat: matrix3")
  (o= (m:quat/from-mat
       (m (v 1 0 0 0) (v 0 0.5 0.86602545 0) (v 0 -0.86602545 0.5 0) (v 0 0 0 1)))
      (m:rotate (qid) (v (/ pi 3) 0 0))
      "quaternion: quat/from-mat: matrix4")
  (o= (m:quat/from-velocity (v 0 (/ pi 4) 0) 0.5)
      (q 0.9807852 0 0.1950903 0)
      "quaternion: quat/from-velocity")
  (o= (m:quat/oriented :local :x (/ pi 2) :y (/ pi 3) :z (/ pi 4))
      (q 0.70105743 0.43045938 0.56098562 -0.09229595)
      "quaternion: quat/oriented"))

(let ((q (q 1 2 3 4)))
  (s= (m:w q) 1 "quaternion: read w")
  (s= (m:x q) 2 "quaternion: read x")
  (s= (m:y q) 3 "quaternion: read y")
  (s= (m:z q) 4 "quaternion: read z")
  (setf (m:w q) 5)
  (setf (m:x q) 6)
  (setf (m:y q) 7)
  (setf (m:z q) 8)
  (s= (m:w q) 5 "quaternion: write w")
  (s= (m:x q) 6 "quaternion: write x")
  (s= (m:y q) 7 "quaternion: write y")
  (s= (m:z q) 8 "quaternion: write z"))

(let ((q (q 1 2 3 4)))
  (s= (m:ref q 0) 1 "quaternion: read index 0")
  (s= (m:ref q 1) 2 "quaternion: read index 1")
  (s= (m:ref q 2) 3 "quaternion: read index 2")
  (s= (m:ref q 3) 4 "quaternion: read index 3")
  (setf (m:ref q 0) 5)
  (setf (m:ref q 1) 6)
  (setf (m:ref q 2) 7)
  (setf (m:ref q 3) 8)
  (s= (m:ref q 0) 5 "quaternion: write index 0")
  (s= (m:ref q 1) 6 "quaternion: write index 1")
  (s= (m:ref q 2) 7 "quaternion: write index 2")
  (s= (m:ref q 3) 8 "quaternion: write index 2"))

(let ((q (q 1 2 3 4)))
  (s= (m:mref q 0 0) 1 "quaternion: read row 0, column 0")
  (s= (m:mref q 0 1) 2 "quaternion: read row 0, column 1")
  (s= (m:mref q 0 2) 3 "quaternion: read row 0, column 2")
  (s= (m:mref q 0 3) 4 "quaternion: read row 0, column 3")
  (setf (m:mref q 0 0) 5)
  (setf (m:mref q 0 1) 6)
  (setf (m:mref q 0 2) 7)
  (setf (m:mref q 0 3) 8)
  (s= (m:mref q 0 0) 5 "quaternion: write row 0, column 0")
  (s= (m:mref q 0 1) 6 "quaternion: write row 0, column 1")
  (s= (m:mref q 0 2) 7 "quaternion: write row 0, column 2")
  (s= (m:mref q 0 3) 8 "quaternion: write row 0, column 3"))

(progn
  (o= m:+q-id+ (q 1 0 0 0) "quaternion: constant: identity"))

(let ((a (q 0.4110496 -0.87680984 -0.62870455 0.6163341))
      (b (q 0.1166687 0.42538047 0.7360425 0.19508076))
      (expected1 (q 0.5277183 -0.45142937 0.10733795 0.81141484))
      (expected2 (q 42.4110496 41.12319016 41.3712954 42.6163341))
      (out (qid)))
  (o= (m:+ a b) expected1 "quaternion + quaternion (allocating)")
  (o= (m:+ a 42) expected2 "quaternion + scalar (allocating)")
  (m:+! a b out)
  (o= out expected1 "quaternion + quaternion (in-place)")
  (m:+! a 42 out)
  (o= out expected2 "quaternion + scalar (in-place)"))

(let ((a (q -0.16772795 -0.7287135 -0.8905144 0.55699535))
      (b (q -0.69658303 0.6168339 -0.7841997 0.094441175))
      (expected1 (q 0.5288551 -1.3455474 -0.1063147 0.46255416))
      (expected2 (q -0.5877279 -1.1487135 -1.3105144 0.1369953))
      (out (qid)))
  (o= (m:- a b) expected1 "quaternion - quaternion (allocating)")
  (o= (m:- a 0.42) expected2 "quaternion - scalar (allocating)")
  (m:-! a b out)
  (o= out expected1 "quaternion - quaternion (in-place)")
  (m:-! a 0.42 out)
  (o= out expected2 "quaternion - scalar (in-place)"))

(let ((a (q 1 2 3 4))
      (b (q 10 20 30 40))
      (expected1 (q -280 40 60 80))
      (expected2 (q 0.5 1 1.5 2))
      (out (qid)))
  (o= (m:* a b) expected1 "quaternion * quaternion (allocating)")
  (o= (m:* a 0.5) expected2 "quaternion * scalar (allocating)")
  (m:*! a b out)
  (o= out expected1 "quaternion * quaternion (in-place)")
  (m:*! a 0.5 out)
  (o= out expected2 "quaternion * scalar (in-place)"))

(let ((q (q 0.9498384 0.4066379 -0.72961855 0.9857626))
      (expected (q 1.0034447 0.4295874 -0.7707963 1.0413964))
      (out (qid)))
  (o= (m:/ q 0.94657767) expected "quaternion / scalar (allocating)")
  (m:/! q 0.94657767 out)
  (o= out expected "quaternion / scalar (in-place)"))

(let ((q (q 0.87 0.65 -0.11 -0.47))
      (expected (q 0.87 -0.65 0.11 0.47))
      (out (qid)))
  (o= (m:conjugate q) expected "quaternion: conjugate (allocating)")
  (m:conjugate! q out)
  (o= out expected "quaternion: conjugate (in-place)"))

(let ((q (q 1 2 3 4))
      (out (qid)))
  (ok (not (eq (m:copy q) q)) "quaternion: copy (allocating)")
  (m:copy! q out)
  (o= q out "quaternion: copy (in-place)"))

(progn
  (o= (m:default (q 1 2 3 4)) (qid) "quaternion: default"))

(progn
  (s= (m:magnitude (qid)) 1 "quaternion: dot (test 1)")
  (s= (m:magnitude (q 0.32979298 0.2571392 0.19932675 0.2647184)) 0.5335644
      "quaternion: dot (test 2)"))

(let ((expected (q 0.86602545 0 0.5 0))
      (out (qid)))
  (m:from-axis-angle! (v 0 1 0) (/ pi 3) out)
  (o= out expected "quaternion: from-axis-angle (in-place)"))

(let ((expected (m:rotate (qid) (v (/ pi 3) 0 0)))
      (out (qid)))
  (m:from-matrix! (m (v 1 0 0) (v 0 0.5 0.86602545) (v 0 -0.86602545 0.5)) out)
  (o= out expected "quaternion: from-matrix: matrix3 (in-place)")
  (m:from-matrix! (m (v 1 0 0 0) (v 0 0.5 0.86602545 0) (v 0 -0.86602545 0.5 0) (v 0 0 0 1)) out)
  (o= out expected "quaternion: from-matrix: matrix4 (in-place)"))

(let ((expected (q 0.9807852 0 0.1950903 0))
      (out (qid)))
  (m:from-velocity! (v 0 (/ pi 4) 0) 0.5 out)
  (o= out expected "quaternion: from-velocity (in-place)"))

(let ((out (qid)))
  (o= (m:id (q 1 2 3 4)) (qid) "quaternion: id (allocating)")
  (m:id! out)
  (o= out (qid) "quaternion: id (in-place)")
  (ok (m:id? (qid)) "quaternion: id?"))

(let ((q (q 0.19171429 -0.8571534 0.4451759 0.39651704))
      (expected (q 0.17012934 0.76064724 -0.39505392 -0.35187355))
      (out (qid)))
  (o= (m:inverse q) expected "quaternion: inverse (allocating)")
  (m:inverse! q out)
  (o= out expected "quaternion: (in-place)"))

(progn
  (pass "quaternion: magnitude-squared"))

(let ((q (q -0.1677279 -0.7287135 -0.8905144 0.55699535))
      (expected (q 0.1677279 0.7287135 0.8905144 -0.55699535))
      (out (qid)))
  (o= (m:negate q) expected "quaternion: negate (allocating)")
  (m:negate! q out)
  (o= out expected "quaternion: negate (in-place)"))

(let ((q (q -0.6589291 0.23270178 -0.1047523 0.6163341))
      (expected (q -0.70274895 0.24817683 -0.1117185 0.6573213))
      (out (qid)))
  (o= (m:normalize q) expected "quaternion: normalize (allocating)")
  (m:normalize! q out)
  (o= out expected "quaternion: normalize (in-place)"))

(let ((expected (q 0.70105743 0.43045938 0.56098562 -0.09229595))
      (out (qid)))
  (m:orient! :local out :x (/ pi 2) :y (/ pi 3) :z (/ pi 4))
  (o= out expected "quaternion: orient (in-place)"))

(let ((a (q 0.19171429 -0.8571534 0.4451759 0.39651704))
      (b (q 0.4891241 -0.3848322 -0.9384121 0.389941))
      (expected1 (q 0.0213853 0.0416263 0.1735096 0.9837196))
      (expected2 (q 0.86602545 0.5 0 0))
      (out (qid)))
  (o= (m:rotate a b) expected1 "quaternion: rotate: by quaternion (allocating)")
  (m:rotate! a b out)
  (o= out expected1 "quaternion: rotate: by quaternion (in-place)")
  (o= (m:rotate (qid) (v (/ pi 3) 0 0))
      expected2
      "quaternion: rotate: by euler angles (allocating)")
  (m:rotate! (qid) (v (/ pi 3) 0 0) out)
  (o= out expected2 "quaternion: rotate: by euler angles (in-place)"))

(let ((a (q -0.15230274 0.7359729 -0.27456188 -0.28505945))
      (b (q 0.594954 0.030960321 -0.037411213 -0.02747035))
      (expected (q -0.5157237 0.4865686 -0.16367096 -0.17777666))
      (out (qid)))
  (o= (m:slerp a b 0.5) expected "quaternion: slerp (allocating)")
  (m:slerp! a b 0.5 out)
  (o= out expected "quaternion: slerp (in-place)"))

(let ((q (q 1 2 3 4)))
  (a= (m:to-array (q 1 2 3 4) :single-float)
      #(1 2 3 4)
      "quaternion: to-array (single-float, allocating)")
  (a= (m:to-array (q 1 2 3 4) :double-float)
      #(1 2 3 4)
      "quaternion: to-array (double-float, allocating)")
  (m:to-array! q :single-float)
  (oa= q (m::components/single q) "quaternion: to-array (single-float, in-place)")
  (ok (eq (m:to-array! q :double-float) (m::components q))
      "quaternion: to-array (double-float, in-place)"))

(let ((q (q 1 0.86602545 0.5 0))
      (expected (v 2.0943952 1.5707964 1.0471976))
      (out (v0 3)))
  (o= (m:to-euler-angles q) expected "quaternion: to-euler-angles (allocating)")
  (m:to-euler-angles! q out)
  (o= out expected "quaternion: to-euler-angles (in-place)"))

(let ((q (m:rotate (qid) (v (/ pi 3) 0 0)))
      (m3-expected (m (v 1 0 0) (v 0 0.5 0.86602545) (v 0 -0.86602545 0.5)))
      (m4-expected (m (v 1 0 0 0) (v 0 0.5 0.86602545 0) (v 0 -0.86602545 0.5 0) (v 0 0 0 1)))
      (m3-out (mid 3))
      (m4-out (mid 4)))
  (o= (m:to-matrix3 q) m3-expected "quaternion: to-matrix3 (allocating)")
  (o= (m:to-matrix4 q) m4-expected "quaternion: to-matrix4 (allocating)")
  (m:to-matrix3! q m3-out)
  (m:to-matrix4! q m4-out)
  (o= m3-out m3-expected "quaternion: to-matrix3 (in-place)")
  (o= m4-out m4-expected "quaternion: to-matrix4 (in-place)"))

(finalize)
